



:::::::: a note about API vs: UI naming ::::::::


Aux data is stuff like the JPEG which is attached to the Object/Thing
with OID 42; for the REST API there are READ and UPDATE methods
defined for (eg) "/api/object/42":

    [ '/api/object/OID', 'READ', \&api_read_oid_aux, 'OID' ], # *** AUX ***
    [ '/api/object/OID', 'UPDATE', \&api_update_oid_aux, 'OID' ], # *** AUX ***

...and these are separate to the READ/UPDATE/DELETE methods which are
defined for the very similarly named "/api/object/42.xml"; the
difference is easy to explain: the latter operate on the image
metadata (image title, tags, stuff like that) whereas the former reads
and updates the actual JPEG.

In the UI, naming is marginally more complex since verbs are embedded
in the URLs and prettymuch the only method we have available is
GET/POST; so the equivalents we have got are:

    [ '/ui/read-data/OID', 'READ', \&handle_noop ], # *** AUX, RAW ***
    [ '/ui/update-data/OID.html', 'POST', \&handle_noop ], # *** AUX ***

The former returns the JPEG (or MP3, whatever) and so does not take a
".html" suffix; the latter is not a PUT operation so is likely to be a
form generating a HTML "success" message, hence it takes a ".html"
suffix.

:::::::: coding-conventions.txt ::::::::

There *is* a rough system to the Mine code naming schemes, although
there are still deviations, bugs and ambiguities.


Approximately it runs like this:

* Protomine is procedural code which calls a lot of OOPS code

* Procedural subroutines are typically named "foo_bar" all lowercase/underbar

* The OOPS classes are typically named Java-style, "FooBar", capital first letter

* This is also reflected in filenames

* The OOPS method calls are also Java style, "fooBar", lowercase first letter

* Where no uppercase letter/underbar separator would exist, you are outta luck, sorry

* non-oops subroutines within a class, have a leading underbar ("_foo")

* non-oops filenames tend to be named "foo-bar.pl"

* Perl OOPS has method inheritance, but not data inheritance.  The
  code is written so the constructor (method "new") need not be
  overridden in subclasses; instead subclass initialisation is left to
  a method ("boot") which MUST BE DEFINED IN EACH SUBCLASS and which
  is called by the parent's constructor.


There are two primary classes which form the bulk of the codebase,
they are "Thing" and "MineUI"

* Thing is the parent class for all database types; it manages a
  directory of files named by integers "1" upwards; this number is
  known generically as "the Id" but in each subclass will have a
  different name - objectId, tagId, relationId, etc...

  The file contains metadata for the object, a set of key/value pairs
  in the java parameter syntax, accepting all of:

	foo bar
	foo=bar
	foo: bar

  ...but only emitting output in the last of these formats.

  Like most Perl objects, Thing is a hashref; it defines several keys:

    $self->{CLASS} - what I am
    $self->{DATA} - a hashref for holding the data from the above file
    $self->{DIRECTORY} - name of directory containing the files 
    $self->{ID_KEY} - what to refer to the "Id" as, in this class
    $self->{NAME_KEY} - What data key will hold the Thing's "name"
    $self->{DO_UNIQUE_NAMES} - boolean, enforce name uniqueness in this database?


    for the next section, the keys of these hashrefs correspond to the
    keys of %{DATA}; 

    $self->{VALID_KEYS} - hashref, defines what keys may be set/got from %{DATA}
    $self->{REQUIRED_KEYS} - these keys must be present for the Thing to be considered valid
    $self->{WRITABLE_KEYS} - hashref, these keys are the only ones which will be stored to disk

    for instance if $self->{REQUIRED_KEYS}->{foo} has a defined value,
    it means that "foo" is a *required* key for the Thing if it is to
    be considered valid.

    for instance if $self->{VALID_KEYS}->{bar} is not a defined value,
    any attempt to set the 'bar' parameter for the thing, will abort;
    as a special case if the value for $self->{VALID_KEYS}->{bar} is a
    listref, then the list defines the permitted values to which 'bar'
    may be set, effectively turning 'bar' into an enumeration.

    Most of the above are meant to be dealt with via accessor methods;
    note also that the name of the "thingName" parameter will vary
    between subclasses, hence the reason for the NAME_KEY setting, and
    the behaviour of the Thing->name() method.

    Subclasses of Thing include: Relation, Tag and Object; the first
    two are trivial, the third extends Thing to add the concept of
    "Auxilliary Data".

    From the perspective of the Mine, an object exists because there
    exists a file containing metadata about it.  What the object
    actually is - a JPEG, PDF, HTML - is almost irrelevant to the
    database bookkeeping, and is stored in an auxilliary file "1.data"
    alongside the "1" file which stores metadata for objectId #1.


* MineUI




:::::::: api-urls.txt ::::::::

ReST API URLs:

	/api/config
		READ -> retreive config object
		UPDATE -> update of config object

	/api/meta
		READ -> redirect to /api/object

	/api/meta/<objectID>
		READ -> retreive meta object
		UPDATE -> update of meta object
		DELETE -> redirect to /api/object/<objectID>

	/api/object
		READ -> retreive list of objectIDs
		CREATE -> insert new object+meta; option to clone?

	/api/object/<objectID>
		READ -> retreive object
		UPDATE -> update of object
		DELETE -> deletion of object+meta

	/api/object/<objectID>/clone
		READ -> retreive list of clones of <objectID>
		CREATE -> create duplicate of <objectID>

	/api/relation
		READ -> retreive list of relationIDs
		CREATE -> insert of new

	/api/relation/<relationID>
		READ -> retreive relation object
		UPDATE -> update of relation object
		DELETE -> deletion of relation

	/api/tag
		READ -> retreive list of tagIDs
		CREATE -> insert of new

	/api/tag/<tagID>
		READ -> retreive tag object
		UPDATE -> update of tag object
		DELETE -> deletion of tag

** TODO - work out search/select syntax
** eg: using CREATE to pass objects in/out of
**   /api/select/object
**   /api/select/relation
**   /api/select/tag

------------------------------------------------------------------

Remote Access URLs

	/api/share/url/RID
		READ -> get the URL for feed to RID

	/api/share/url/RID/OID
		READ -> get the URL for OID shared to RID

	/api/share/redirect/RID
		READ -> issue a redirect to the feed for RID

	/api/share/redirect/RID/OID
		READ -> issue a redirect to OID shared to RID

	/share/COOKIE
		READ -> retreive the object represented by cookie
		cookie -> B64(AES("RID/RVERSION[/OID]"))

:::::::: authentication.txt ::::::::

Authentication:

For Version 1.0, HTTP Basic Authentication is used to authenticate the
user for all interaction with the "/ui" and "/api" hierarchies ; it is
assumed that access will be made secret by HTTPS.

There is no authentication for "/pub" URLs.

:::::::: basic-ui-urls.txt ::::::::

Human User Interface URLs:

The protomine will also be equipped with a basic HTML user interface;
largely this can shadow the ReST API for fundamental operations, and
then can be extended out to provide extra functionality for the
protomine.

Later, "full" implementations are expected to implement tools and
plugins either on the server side, or as AJAX objects using the ReST
API, so the pure HTML user interface will gradually die out.

The pure HTML user interface is inherently limited to READ(GET) and
maybe CREATE(POST) operations, so commands that require UPDATE or
DELETE will need be faked with custom POST dialogues; thus we cheat
orthogonally by suffinxing API URIs with "/delete" etc, to make HTML
analogues.


Certain tasks need to be available to the user, which in "full" Mine!
implementations will be performed by sucking a JSON object from the
Mine, updating it and squirting it back up to the Mine; the pure HTML
Mine UI will not have that capability, so the "update" URLs of various
objects must provide them.

:::::::: HOWTO ::::::::

  revoke a relationship's existing fetchCookies
	update relationVersion using /ui/relation/<relationID>/update


Hooks into /api/select: (may cause pushback on "/api"))

	IDEAS ONLY
	/ui/select/object/date/YYYY[/MM/DD/HH/MM/SS]
	/ui/select/object/embargoed # not yet visible
	/ui/select/object/expired # was previously visible
	/ui/select/object/hidden # either embargoed or expired
	/ui/select/object/recent # last N
	/ui/select/object/recent/<integer>
	/ui/select/object/tagged/<tag>
	/ui/select/object/visibleto/<relationID>
	/ui/select/object/visibleto/<relationName>

:::::::: feed-generation.txt ::::::::

Feed Generation

Version 1.0 of the algorithm for feed generation is:

1) consider a relationship/feed for someone named "Perry"

2) for Perry, extract the list of "inclusive" and "exclusive" tags
   which are associated with that relationship, for instance:

	INCLUSIVE TAGS: "wine", "women", "song", "hippos"

	EXCLUSIVE TAGS: "not:white-wine" 

3) for each and every object in the database, extract the list of tags
   that are associated with the object.

4a) if the object lacks status:published, move on

4b) if any of those object tags match the list of Perry's inclusive
    tags then CONSIDER INCLUDING the object in the feed.

4c) if any of those object tags match the list of Perry's exclusive
    tags (eg: "white-wine" matches Perry's "not:white-wine") then
    RESCIND ANY CONSIDERATION OF INCLUDING the object in the feed.

4d) if any of those object tags are explicitly "for:perry", then
    ABSOLUTELY INCLUDE the object in the feed, irrespective of the
    above considerations.

4e) The feed will contain any objects which are absolutely included,
    and any for which consideration was not rescinded.

:::::::: rest-crud.txt ::::::::

ReST CRUD Mappings to HTTP methods:

	CREATE (POST)
	READ (GET)
	UPDATE (PUT)
	DELETE (DELETE)

PUT can be faked via POST of a http-uri-encoded object with:

	"_method" set to "POST"

	"_data" set to the object data (TBD)

	"_type" set to the content-type of the PUT request; given the
	"update" nature of the fake PUT, this latter MAY be ignored by
	the server, but clients MUST send it.

DELETE can be faked via POST of a http-uri-encoded object with:

	"_method" set to "DELETE"

